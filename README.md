# retry ♻️¯\_ʕ◔ϖ◔ʔ_/¯[![Build Status](https://travis-ci.org/flowchartsman/retry.svg?branch=master)](https://travis-ci.org/flowchartsman/v8) [![Go Report Card](https://goreportcard.com/badge/github.com/flowchartsman/retry)](https://goreportcard.com/report/github.com/flowchartsman/retry) [![GoDoc](https://godoc.org/github.com/flowchartsman/retry?status.svg)](https://godoc.org/github.com/flowchartsman/retry)

**retry** is a simple retrier for golang with exponential backoff and context support.

It exists mainly because I found the other implementations either too heavy in implementation or too tedious to use. I like the efficiency of delays generated by closures and the simplicity of just returning errors, with a special case for errors you want to stop on.

If you're mostly doing HTTP work and you are comfortable with the requirents of converting everything to *io.ReadSeeker*, I highly recommend [hashicorp/go-retryablehttp](https://github.com/hashicorp/go-retryablehttp) (which I didn't use because I didn't want to cache my large POSTs) or [facebookgo/httpcontrol](https://github.com/facebookgo/httpcontrol) (which I didn't use because it only retries GETs).

## Usage

### Simple
```go
package main

import (
	"fmt"
	"net/http"
	"time"

	"github.com/flowchartsman/retry"
)

func main() {
	err := retry.Do(retry.ExponentialBackoff(5, 100*time.Millisecond, 1*time.Second), func() error {
		resp, err := http.Get("http://golang.org")
		switch {
		case err != nil:
			return err
		case resp.StatusCode == 0 || resp.StatusCode >= 500:
			return fmt.Errorf("Retryable HTTP status: %s", http.StatusText(resp.StatusCode))
		case resp.StatusCode != 200:
			return retry.Stop(fmt.Errorf("Non-retryable HTTP status: %s", http.StatusText(resp.StatusCode)))
		}
		return nil
	})
	if err != nil {
		// Do your thang
	}
}
```

### With context
```go
package main

import (
	"context"
	"fmt"
	"net/http"
	"time"

	"github.com/flowchartsman/retry"
)

func main() {
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Millisecond)
	defer cancel()
	err := retry.DoWithContext(ctx, retry.ConstantBackoff(5, 100*time.Millisecond), func(ctx context.Context) error {
		req, _ := http.NewRequest("GET", "http://golang.org/notfastenough", nil)
		req = req.WithContext(ctx)
		resp, err := http.DefaultClient.Do(req)
		if err != nil {
			return err
		}
		if resp.StatusCode != http.StatusOK {
			return fmt.Errorf("OMG AWFUL CODE %d", resp.StatusCode)
			// or decide not to retry
		}
		return nil
	})
	if err != nil {
		// Do your thang
	}
}
```

## Reference

See:
* https://en.wikipedia.org/wiki/Exponential_backoff
* https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/
